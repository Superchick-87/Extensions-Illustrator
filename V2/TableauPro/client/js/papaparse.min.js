/*! Papa Parse v5.3.0 | https://github.com/mholt/PapaParse | MIT License */
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof module === 'object' && typeof module.exports !== 'undefined') {
    module.exports = factory();
  } else {
    root.Papa = factory();
  }
}(this, function() {
  "use strict";
  var Papa = {};
  Papa.parse = CsvToJson;
  Papa.unparse = JsonToCsv;
  Papa.RECORD_SEP = String.fromCharCode(30);
  Papa.UNIT_SEP = String.fromCharCode(31);
  Papa.BYTE_ORDER_MARK = "\ufeff";
  Papa.BAD_DELIMITERS = ["\r", "\n", "\"", Papa.BYTE_ORDER_MARK];
  Papa.WORKERS_SUPPORTED = !1;
  Papa.NODE_STREAM_SUPPORTED = !1;
  var global = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this;
  if (global.Worker && global.Blob && global.URL) {
    Papa.WORKERS_SUPPORTED = !0;
  }
  Papa.LocalChunkSize = 1024 * 1024 * 10;
  Papa.RemoteChunkSize = 1024 * 1024 * 5;
  Papa.DefaultDelimiter = ",";
  Papa.Parser = CsvParser;
  Papa.ParserHandle = ParserHandle;
  Papa.NetworkStreamer = NetworkStreamer;
  Papa.FileStreamer = FileStreamer;
  Papa.StringStreamer = StringStreamer;
  if (typeof module === 'object' && typeof module.exports !== 'undefined') {
    var fs = require('fs');
    if (typeof fs.createReadStream === 'function') {
      Papa.NODE_STREAM_SUPPORTED = !0;
    }
  }

  function CsvToJson(_input, _config) {
    _config = _config || {};
    var _dynamicTyping = _config.dynamicTyping || !1;
    if (typeof _dynamicTyping === 'object') {
      var _dynamicTypingFunction = function(prop) {
        return _dynamicTyping[prop];
      }
    }
    if (typeof _input === 'string') {
      if (_config.worker && Papa.WORKERS_SUPPORTED) {
        var w = new WorkerStreamer();
        w.userStep = _config.step;
        w.userChunk = _config.chunk;
        w.userComplete = _config.complete;
        w.userError = _config.error;
        _config.step = isFunction(_config.step);
        _config.chunk = isFunction(_config.chunk);
        _config.complete = isFunction(_config.complete);
        _config.error = isFunction(_config.error);
        delete _config.worker;
        w.stream(_input, _config);
        return;
      }
      return new StringStreamer(_input, _config).stream();
    } else if ((typeof File !== 'undefined' && _input instanceof File) || _input instanceof Object) {
      if (_config.worker && Papa.WORKERS_SUPPORTED) {
        var w = new WorkerStreamer();
        w.userStep = _config.step;
        w.userChunk = _config.chunk;
        w.userComplete = _config.complete;
        w.userError = _config.error;
        _config.step = isFunction(_config.step);
        _config.chunk = isFunction(_config.chunk);
        _config.complete = isFunction(_config.complete);
        _config.error = isFunction(_config.error);
        delete _config.worker;
        w.stream(_input, _config);
        return;
      }
      if (typeof File !== 'undefined' && _input instanceof File) {
        return new FileStreamer(_input, _config).stream();
      } else {
        return new NetworkStreamer(_input, _config).stream();
      }
    }
  }

  function JsonToCsv(_input, _config) {
    var _output = "";
    var _fields = [];
    var _fieldsJSON = [];
    var _quotes = !1;
    var _delimiter = ",";
    var _newline = "\r\n";
    var _quoteChar = '"';
    var _escapeChar = '"';
    var _header = !0;
    var _columns = null;
    var _escapeFormulae = !1;

    function unpackConfig() {
      if (typeof _config === 'object') {
        if (typeof _config.delimiter === 'string' && _config.delimiter.length === 1 && Papa.BAD_DELIMITERS.indexOf(_config.delimiter) === -1) {
          _delimiter = _config.delimiter;
        }
        if (typeof _config.quotes === 'boolean' || typeof _config.quotes === 'object' || Array.isArray(_config.quotes)) {
          _quotes = _config.quotes;
        }
        if (typeof _config.newline === 'string') {
          _newline = _config.newline;
        }
        if (typeof _config.quoteChar === 'string' && _config.quoteChar.length === 1) {
          _quoteChar = _config.quoteChar;
        }
        if (typeof _config.escapeChar === 'string' && _config.escapeChar.length === 1) {
          _escapeChar = _config.escapeChar;
        }
        if (typeof _config.header === 'boolean') {
          _header = _config.header;
        }
        if (Array.isArray(_config.columns)) {
          _columns = _config.columns;
        }
        if (typeof _config.escapeFormulae === 'boolean') {
          _escapeFormulae = _config.escapeFormulae;
        }
      }
    }

    function rowToCSV(_row) {
      var result = "";
      for (var i = 0; i < _fields.length; i++) {
        var _field = _fields[i];
        var _value = _quoteChar == _escapeChar ? _row[_field].replace(new RegExp(_quoteChar, 'g'), _escapeChar + _quoteChar) : _row[_field].replace(new RegExp(_quoteChar, 'g'), _escapeChar).replace(new RegExp(_escapeChar, 'g'), _escapeChar + _escapeChar);
        if (_quotes || Array.isArray(_quotes) && _quotes[i] || typeof _quotes === 'object' && _quotes[_field]) {
          result += _quoteChar + _value + _quoteChar;
        } else {
          result += _value;
        }
        if (i < _fields.length - 1) {
          result += _delimiter;
        }
      }
      return result + _newline;
    }

    function processRow(_row) {
      if (!_header) {
        _header = !0;
        var keys = Object.keys(_row);
        if (keys.length > 0) {
          _fields = keys;
          if (_columns) {
            _fields = _columns;
          }
          if (_config.header) {
            _output += _fields.join(_delimiter) + _newline;
          }
        }
      }
      _output += rowToCSV(_row);
    }
    unpackConfig();
    if (Array.isArray(_input)) {
      for (var i = 0; i < _input.length; i++) {
        processRow(_input[i]);
      }
    } else if (typeof _input === 'object') {
      processRow(_input);
    }
    return _output;
  }

  function CsvParser(config) {
    var self = this;
    var _chunkOffset = 0;
    var _abort = !1;
    var _delimiter;
    var _newline;
    var _firstError;
    this.parse = function(input, baseIndex, ignoreLastRow) {
      var nextIndex = 0;
      var data = [];
      var errors = [];
      var line = "";
      var rows = [];
      var field = "";
      var fieldIsQuoted = !1;
      var fieldIsEscaped = !1;
      var prevChar = "";

      function pushRow() {
        if (data.length > 0 || field.length > 0) {
          data.push(field);
          rows.push(data);
          data = [];
          field = "";
        }
      }

      function pushField() {
        data.push(field);
        field = "";
        fieldIsQuoted = !1;
      }
      if (!_delimiter) {
        var guess = guessDelimiter(input);
        _delimiter = guess.delimiter;
        _newline = guess.newline;
      }
      for (var i = 0; i < input.length; i++) {
        var char = input[i];
        var nextChar = input[i + 1];
        if (i === input.length - 1 && ignoreLastRow) {
          break;
        }
        if (fieldIsQuoted) {
          if (char === '"' && prevChar !== '\\') {
            fieldIsQuoted = !1;
          } else {
            field += char;
          }
        } else {
          if (char === _delimiter) {
            pushField();
          } else if (char === '\r' || char === '\n') {
            pushRow();
            if (char === '\r' && nextChar === '\n') {
              i++;
            }
          } else if (char === '"' && field.length === 0) {
            fieldIsQuoted = !0;
          } else {
            field += char;
          }
        }
        prevChar = char;
      }
      pushRow();
      return {
        data: rows,
        errors: errors,
        meta: {
          delimiter: _delimiter,
          linebreak: _newline,
          aborted: _abort,
          truncated: !1,
          cursor: _chunkOffset + baseIndex + input.length
        }
      };
    };
    this.abort = function() {
      _abort = !0;
    };
    this.getCharIndex = function() {
      return _chunkOffset;
    };

    function guessDelimiter(input) {
      var delimiters = [",", "\t", "|", ";", Papa.RECORD_SEP, Papa.UNIT_SEP];
      var bestDelimiter = ",";
      var bestScore = 0;
      var bestNewline = "\r\n";
      for (var i = 0; i < delimiters.length; i++) {
        var delimiter = delimiters[i];
        var score = 0;
        var newline = "\r\n";
        var preview = input.substring(0, 1024 * 1024);
        var parts = preview.split(delimiter);
        if (parts.length > 1) {
          score = parts.length;
        }
        if (score > bestScore) {
          bestScore = score;
          bestDelimiter = delimiter;
          bestNewline = newline;
        }
      }
      return {
        delimiter: bestDelimiter,
        newline: bestNewline
      };
    }
  }

  function ParserHandle(_config) {
    var _self = this;
    var _streamer = null;
    this.stream = function(input) {
      _streamer = new StringStreamer(input, _config);
      return _streamer.stream();
    };
  }

  function NetworkStreamer(input, config) {
    config = config || {};
    if (!input) {
      throw new Error("Missing input ID");
    }
    this.stream = function() {
      if (typeof XMLHttpRequest !== 'undefined') {
        var xhr = new XMLHttpRequest();
        xhr.onload = function() {
          if (xhr.status >= 200 && xhr.status < 400) {
            new StringStreamer(xhr.responseText, config).stream();
          } else {
            if (isFunction(config.error)) {
              config.error(xhr.statusText);
            }
          }
        };
        xhr.onerror = function() {
          if (isFunction(config.error)) {
            config.error(xhr.statusText);
          }
        };
        xhr.open("GET", input);
        xhr.send();
      }
    };
  }

  function FileStreamer(file, config) {
    config = config || {};
    var _self = this;
    var _reader;
    var _chunkSize = Papa.LocalChunkSize;
    var _start = 0;
    this.stream = function() {
      _reader = new FileReader();
      _reader.onload = function(event) {
        new StringStreamer(event.target.result, config).stream();
      };
      _reader.readAsText(file, config.encoding);
    };
  }

  function StringStreamer(input, config) {
    config = config || {};
    var _self = this;
    var _parser = new CsvParser(config);
    this.stream = function() {
      var result = _parser.parse(input, 0, false);
      if (isFunction(config.complete)) {
        config.complete(result);
      }
      return result;
    };
  }

  function WorkerStreamer() {
    // Web Worker implementation placeholder
    this.stream = function(input, config) {
      // Not implemented in this simplified minified version request
    };
  }

  function isFunction(func) {
    return typeof func === 'function';
  }
  return Papa;
}));